---
title: How to setup OAuth with Github in Botpress using Integrations.
deprecated: false
hidden: true
metadata:
  robots: index
---
OAuth can be very useful especially in cases where validating the identify of the user is crucial. In the example that follows we walk through how we was able to setup OAuth verification with Github as my platform of choice in our Botpress bot.

This was accomplished with the help of a custom integration for setting up OAuth with Github.

## Demo

**When the user is authenticated**

\< insert video >

**When the user is unauthenticated**

\< insert video >

## Bot Setup

The bot setup is straightforward. First, the user is prompted to log in by clicking on a link generated by the integration. Once the login is successful, an event is emitted. This event is captured by a trigger node, which then hands off control to an autonomous node.

![](https://files.readme.io/79f803935423d1748634a0fa8674d9985caa8c706235c6e614008253cfedb2a2-image.png)

<br />

## Integration

The integration has a couple of responsibilities: generating the OAuth link that users will click on and capturing a successful authentication which then emits an event containing the conversation ID and data about the authenticated user.

This is achieved using an action ( here called “Generate OAuth2 URL” ) and the integration’s Botpress webhook handler. The webhook captures successful authentication and emits a Botpress event ( in this case, “User Authenticated” ).

This is achieved by the following code:

```typescript integration.definition.ts
import { conversation, IntegrationDefinition, z } from '@botpress/sdk'
import { integrationName } from './package.json'
import { DEFAULT_STORE_KEY } from 'src/store'

export default new IntegrationDefinition({
  name: integrationName,
  version: '0.0.1',
  readme: 'hub.md',
  icon: 'icon.svg',
  configuration: {
    schema: z.object({
      clientId: z.string(),
      clientSecret: z.string(),
      state: z.string().default("secure_random_string"),
    })
  },
  events: {
    onUserAuthenticated: {
      title: 'User Authenticated',
      description: 'Fires when a user has been authenticated',
      schema: z.object({
        userData: z.any(),
        conversationIdxx: z.string(),
      })
    }
  },
  actions: {
    generateUrl: {
      title: 'Generate OAuth2 URL',
      description: 'Generates an OAuth2 URL to authenticate the user',
      input: {
        schema: z.object({
          conversationId: z.string().default('{{event.conversationId}}').hidden()
        })
      },
      output: {
        schema: z.object({
          url: z.string()
        })
      }
    }
  },
  states: {
    [DEFAULT_STORE_KEY]: {
      type: 'integration',
      schema: z.object({
        bpWebhookUrl: z.string(),
        conversationId: z.string(),
      }),
    }
  }
})
```

```typescript index.ts
import * as sdk from "@botpress/sdk";
import * as bp from ".botpress";
import { Store } from './store'

export default new bp.Integration({
  register: async ({ webhookUrl, client, ctx }) => {
    const store = new Store(client, ctx);
    await store.initialize({
      bpWebhookUrl: webhookUrl,
      conversationId: "",
    })
    console.log("Integration registered")
  },
  unregister: async () => {},
  actions: {
    generateUrl: async ({ client, input, ctx } ) => {
      const store = new Store(client, ctx);
      await store.load();

      await store.set("conversationId", input.conversationId);
      const webhookUrl = await store.get("bpWebhookUrl");

      const clientId = ctx.configuration.clientId;
      const redirectUri = webhookUrl; // Redirect back to the integration
      const state = ctx.configuration.state; // For CSRF protection
      const scope = "read:user"; // Request access to read user profile

      const githubOAuthUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(
        redirectUri
      )}&scope=${scope}&state=${state}`;

      return { url: githubOAuthUrl };
    },
  },
  channels: {},
  handler: async ({ req, client, ctx }) => {
    const store = new Store(client, ctx);
    await store.load();
    const webhookUrl = await store.get("bpWebhookUrl");

    // Construct a URLSearchParams object
    const params = new URLSearchParams(req.query);

    // Extract query parameters
    const code = params.get("code"); // Extract 'code'
    const sec_string = params.get("state"); // Extract 'state'

    // Verify the `state` to protect against CSRF
    if (sec_string !== ctx.configuration.state) {
      return { status: 403, message: "Invalid state" };
    }

    // Exchange the code for an access token
    const tokenResponse: any = await fetch("https://github.com/login/oauth/access_token", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify({
        client_id: ctx.configuration.clientId,
        client_secret: ctx.configuration.clientSecret,
        code,
        redirect_uri: webhookUrl,
      }),
    }).then((res) => res.json());

    // Fetch user data
    const userData: any = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${tokenResponse.access_token}`,
      },
    }).then((res) => res.json());

    // Send a message to the user
    const conversationId = await store.get("conversationId");

    await client.createEvent({
      type: "onUserAuthenticated",
      conversationId: conversationId,
      payload: {
        conversationIdxx: conversationId,
        userData: userData,
      }
    })

    return { status: 200, message: "Success" };
  },
});
```

```typescript store.ts
import * as sdk from "@botpress/sdk";

export const DEFAULT_STORE_KEY = "globalStore";

export class Store {
  private client: sdk.IntegrationSpecificClient<any>;
  private ctx: sdk.IntegrationContext;
  private globalStoreKey: string;
  private validKeys: string[] = [];

  constructor(
    client: sdk.IntegrationSpecificClient<any>,
    ctx: sdk.IntegrationContext,
    globalStoreKey = DEFAULT_STORE_KEY
  ) {
    this.client = client;
    this.ctx = ctx;
    this.globalStoreKey = globalStoreKey;
  }

  private async fetchGlobalStore(): Promise<Record<string, any>> {
    const result = await this.client.getState({
      type: "integration",
      id: this.ctx.integrationId,
      name: this.globalStoreKey,
    });
    return result.state.payload || {}; // Default to an empty object if no state exists
  }

  private async updateGlobalStore(store: Record<string, any>): Promise<void> {
    console.log('updating store', store)
    await this.client.setState({
      type: "integration",
      id: this.ctx.integrationId,
      name: this.globalStoreKey,
      payload: store,
    });
  }

  async initialize(initialState: Record<string, any>): Promise<void> {
    this.validKeys = Object.keys(initialState);
    await this.updateGlobalStore(initialState);
  }

  async load(): Promise<void> {
    const store = await this.fetchGlobalStore();
    this.validKeys = Object.keys(store);
  }

  private validateKey(key: string): void {
    if (!this.validKeys.includes(key)) {
      throw new Error(`Key ${key} is not a valid key, valid keys are: ${this.validKeys.join(", ")}`);
    }
  }

  async set(key: string, value: any): Promise<void> {
    this.validateKey(key);
    const store = await this.fetchGlobalStore();
    console.log('got store', store);
    store[key] = value; // Update the key in the global store
    await this.updateGlobalStore(store); // Save the updated store back
  }

  async get(key: string): Promise<any> {
    this.validateKey(key);
    const store = await this.fetchGlobalStore();
    return store[key]; // Retrieve the value for the key
  }
}

```